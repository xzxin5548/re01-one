let cameras = [
    {
        id: 0,
        img_name: "00001",
        width: 1959,
        height: 1090,
        position: [
            -2.5199776022057296, -0.09704735754873686, -3.6247725540304545,
        ],
        rotation: [
[
            0.9982731285632193,
            -0.011928707708098955,
            -0.05751927260507243
        ],
        [
            0.0065061360949636325,
            0.9955928229282383,
            -0.09355533724430458
        ],
        [
            0.058381769258182864,
            0.09301955098900708,
            0.8769787916452908
        ],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 1,
        img_name: "00009",
        width: 1959,
        height: 1090,
        position: [
            -2.5199776022057296, -0.09704735754873686, -3.6247725540304545,
        ],
        rotation: [
            [0.9982731285632193, -0.011928707708098955, -0.05751927260507243],
            [0.0065061360949636325, 0.9955928229282383, -0.09355533724430458],
            [0.058381769258182864, 0.09301955098900708, 0.9939511719154457],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 2,
        img_name: "00017",
        width: 1959,
        height: 1090,
        position: [
            -0.7737533667465242, -0.3364271945329695, -2.9358969417573753,
        ],
        rotation: [
            [0.9998813418672372, 0.013742375651625236, -0.0069605529394208224],
            [-0.014268370388586709, 0.996512943252834, -0.08220929105659476],
            [0.00580653013657589, 0.08229885200307129, 0.9965907801935302],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 3,
        img_name: "00025",
        width: 1959,
        height: 1090,
        position: [
            1.2198221749590001, -0.2196687861401182, -2.3183162007028453,
        ],
        rotation: [
            [0.9208648867765482, 0.0012010625395201253, 0.389880004297208],
            [-0.06298204172269357, 0.987319521752825, 0.14571693239364383],
            [-0.3847611242348369, -0.1587410451475895, 0.9092635249821667],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 4,
        img_name: "00033",
        width: 1959,
        height: 1090,
        position: [
            1.742387858893817, -0.13848225198886954, -2.0566370113193146,
        ],
        rotation: [
            [0.24669889292141334, -0.08370189346592856, -0.9654706879349405],
            [0.11343747891376445, 0.9919082664242816, -0.05700815184573074],
            [0.9624300466054861, -0.09545671285663988, 0.2541976029815521],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 5,
        img_name: "00041",
        width: 1959,
        height: 1090,
        position: [
            3.6567309419223935, -0.16470990600750707, -1.3458085590422042,
        ],
        rotation: [
            [0.2341293058324528, -0.02968330457755884, -0.9717522161434825],
            [0.10270823606832301, 0.99469554638321, -0.005638106875665722],
            [0.9667649592295676, -0.09848690996657204, 0.2359360976431732],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 6,
        img_name: "00049",
        width: 1959,
        height: 1090,
        position: [
            3.9013554243203497, -0.2597500978038105, -0.8106154188297828,
        ],
        rotation: [
            [0.6717235545638952, -0.015718162115524837, -0.7406351366386528],
            [0.055627354673906296, 0.9980224478387622, 0.029270992841185218],
            [0.7387104058127439, -0.060861588786650656, 0.6712695459756353],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 7,
        img_name: "00057",
        width: 1959,
        height: 1090,
        position: [4.742994605467533, -0.05591660945412069, 0.9500365976084458],
        rotation: [
            [-0.17042655709210375, 0.01207080756938, -0.9852964448542146],
            [0.1165090336695526, 0.9931575292530063, -0.00798543433078162],
            [0.9784581921120181, -0.1161568667478904, -0.1706667764862097],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 8,
        img_name: "00065",
        width: 1959,
        height: 1090,
        position: [4.34676307626522, 0.08168160516967145, 1.0876221470355405],
        rotation: [
            [-0.003575447631888379, -0.044792503246552894, -0.9989899137764799],
            [0.10770152645126597, 0.9931680875192705, -0.04491693593046672],
            [0.9941768441149182, -0.10775333677534978, 0.0012732004866391048],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 9,
        img_name: "00073",
        width: 1959,
        height: 1090,
        position: [3.264984351114202, 0.078974937336732, 1.0117200284114904],
        rotation: [
            [-0.026919994628162257, -0.1565891128261527, -0.9872968974090509],
            [0.08444552208239385, 0.983768234577625, -0.1583319754069128],
            [0.9960643893290491, -0.0876350978794554, -0.013259786205163005],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
];

// 定义一个摄像机变量，通常从一个摄像机数组中获取第一个摄像机
let camera = cameras[0];

let cams = [
    [0.95,0,0.31,0,0.06,0.99,-0.17,0,-0.31,0.19,0.94,0,0.18,-0.03,-2.65,1],
    [0.94,-0.25,0.22,0,0.04,0.73,0.69,0,-0.33,-0.64,0.71,0,-2.48,-2.28,29.85,1],
    [0.3,0.17,-0.94,0,-0.35,0.94,0.05,0,0.9,0.33,0.34,0,2.57,-0.19,-1.85,1]
]
let camend =cams[1]
let camstart=cams[1]

    // 初始化激活键数组和当前相机索引
    let activeKeys = [];
	let currentCameraIndex = 0;
// 获取投影矩阵的函数，用于将3D场景投影到2D屏幕上
function getProjectionMatrix(fx, fy, width, height) {
    // 近平面和远平面的距离，用于创建视锥体
    const znear = 0.2;
    const zfar = 200;
    // 返回一个4x4的投影矩阵
    return [
        [(2 * fx) / width, 0, 0, 0],// X轴的缩放
        [0, -(2 * fy) / height, 0, 0],// Y轴的缩放，负号表示Y轴翻转
        [0, 0, zfar / (zfar - znear), 1],// Z轴的缩放和移动
        [0, 0, -(zfar * znear) / (zfar - znear), 0],// 透视除法的参数
    ].flat(); // 将矩阵展平为一维数组
}

// 获取视图矩阵的函数，用于确定摄像机在世界空间中的位置和方向
function getViewMatrix(camera) {
    // 摄像机的旋转矩阵，展平为一维数组
    const R = camera.rotation.flat();
    // 摄像机的位置向量
    const t = camera.position;
    // 计算摄像机到世界坐标系的变换矩阵
    const camToWorld = [
        [R[0], R[1], R[2], 0],// 旋转部分
        [R[3], R[4], R[5], 0],
        [R[6], R[7], R[8], 0],
        [
            // 平移部分
            -t[0] * R[0] - t[1] * R[3] - t[2] * R[6],
            -t[0] * R[1] - t[1] * R[4] - t[2] * R[7],
            -t[0] * R[2] - t[1] * R[5] - t[2] * R[8],
            1,
        ],
    ].flat(); // 将矩阵展平为一维数组
    return camToWorld;
}
// function translate4(a, x, y, z) {
//     return [
//         ...a.slice(0, 12),
//         a[0] * x + a[4] * y + a[8] * z + a[12],
//         a[1] * x + a[5] * y + a[9] * z + a[13],
//         a[2] * x + a[6] * y + a[10] * z + a[14],
//         a[3] * x + a[7] * y + a[11] * z + a[15],
//     ];
// }
function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}
function lerp(start, end, t) {
    return start * (1 - t) + end * t;
}



// 计算任意时间点的相机位置参数
function getCameraPositionAtTime(startPos, endPos, t) {
    const easeT = easeInOutCubic(t); // 应用ease-in-out函数

    return startPos.map((startValue, index) => {
        return lerp(startValue, endPos[index], easeT);
    });
}


// 矩阵乘法函数，用于计算两个4x4矩阵的乘积
function multiply4(a, b) {
    // 返回结果矩阵，每个元素是两个矩阵对应元素的乘积之和
    return [
        b[0] * a[0] + b[1] * a[4] + b[2] * a[8] + b[3] * a[12],
        b[0] * a[1] + b[1] * a[5] + b[2] * a[9] + b[3] * a[13],
        b[0] * a[2] + b[1] * a[6] + b[2] * a[10] + b[3] * a[14],
        b[0] * a[3] + b[1] * a[7] + b[2] * a[11] + b[3] * a[15],
        b[4] * a[0] + b[5] * a[4] + b[6] * a[8] + b[7] * a[12],
        b[4] * a[1] + b[5] * a[5] + b[6] * a[9] + b[7] * a[13],
        b[4] * a[2] + b[5] * a[6] + b[6] * a[10] + b[7] * a[14],
        b[4] * a[3] + b[5] * a[7] + b[6] * a[11] + b[7] * a[15],
        b[8] * a[0] + b[9] * a[4] + b[10] * a[8] + b[11] * a[12],
        b[8] * a[1] + b[9] * a[5] + b[10] * a[9] + b[11] * a[13],
        b[8] * a[2] + b[9] * a[6] + b[10] * a[10] + b[11] * a[14],
        b[8] * a[3] + b[9] * a[7] + b[10] * a[11] + b[11] * a[15],
        b[12] * a[0] + b[13] * a[4] + b[14] * a[8] + b[15] * a[12],
        b[12] * a[1] + b[13] * a[5] + b[14] * a[9] + b[15] * a[13],
        b[12] * a[2] + b[13] * a[6] + b[14] * a[10] + b[15] * a[14],
        b[12] * a[3] + b[13] * a[7] + b[14] * a[11] + b[15] * a[15],
    ];// 最终返回一个新的4x4矩阵
}

// invert4函数用于计算4x4矩阵的逆矩阵
function invert4(a) {
    // 计算矩阵的各个子式
    let b00 = a[0] * a[5] - a[1] * a[4];
    let b01 = a[0] * a[6] - a[2] * a[4];
    let b02 = a[0] * a[7] - a[3] * a[4];
    let b03 = a[1] * a[6] - a[2] * a[5];
    let b04 = a[1] * a[7] - a[3] * a[5];
    let b05 = a[2] * a[7] - a[3] * a[6];
    let b06 = a[8] * a[13] - a[9] * a[12];
    let b07 = a[8] * a[14] - a[10] * a[12];
    let b08 = a[8] * a[15] - a[11] * a[12];
    let b09 = a[9] * a[14] - a[10] * a[13];
    let b10 = a[9] * a[15] - a[11] * a[13];
    let b11 = a[10] * a[15] - a[11] * a[14];
    // 计算矩阵的行列式值
    let det =
        b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    // 如果行列式为0，则矩阵不可逆，返回null
        if (!det) return null;
        // 计算逆矩阵的各个元素并返回
    return [
        (a[5] * b11 - a[6] * b10 + a[7] * b09) / det,
        (a[2] * b10 - a[1] * b11 - a[3] * b09) / det,
        (a[13] * b05 - a[14] * b04 + a[15] * b03) / det,
        (a[10] * b04 - a[9] * b05 - a[11] * b03) / det,
        (a[6] * b08 - a[4] * b11 - a[7] * b07) / det,
        (a[0] * b11 - a[2] * b08 + a[3] * b07) / det,
        (a[14] * b02 - a[12] * b05 - a[15] * b01) / det,
        (a[8] * b05 - a[10] * b02 + a[11] * b01) / det,
        (a[4] * b10 - a[5] * b08 + a[7] * b06) / det,
        (a[1] * b08 - a[0] * b10 - a[3] * b06) / det,
        (a[12] * b04 - a[13] * b02 + a[15] * b00) / det,
        (a[9] * b02 - a[8] * b04 - a[11] * b00) / det,
        (a[5] * b07 - a[4] * b09 - a[6] * b06) / det,
        (a[0] * b09 - a[1] * b07 + a[2] * b06) / det,
        (a[13] * b01 - a[12] * b03 - a[14] * b00) / det,
        (a[8] * b03 - a[9] * b01 + a[10] * b00) / det,
    ];
}

// rotate4函数用于绕任意轴旋转矩阵
function rotate4(a, rad, x, y, z) {
    // 对旋转轴向量进行归一化
    let len = Math.hypot(x, y, z);
    x /= len;
    y /= len;
    z /= len;
    // 计算旋转角的正弦和余弦值
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    let t = 1 - c;
    // 计算旋转矩阵的各个元素
    let b00 = x * x * t + c;
    let b01 = y * x * t + z * s;
    let b02 = z * x * t - y * s;
    let b10 = x * y * t - z * s;
    let b11 = y * y * t + c;
    let b12 = z * y * t + x * s;
    let b20 = x * z * t + y * s;
    let b21 = y * z * t - x * s;
    let b22 = z * z * t + c;
    // 返回旋转后的新矩阵
    return [
        a[0] * b00 + a[4] * b01 + a[8] * b02,
        a[1] * b00 + a[5] * b01 + a[9] * b02,
        a[2] * b00 + a[6] * b01 + a[10] * b02,
        a[3] * b00 + a[7] * b01 + a[11] * b02,
        a[0] * b10 + a[4] * b11 + a[8] * b12,
        a[1] * b10 + a[5] * b11 + a[9] * b12,
        a[2] * b10 + a[6] * b11 + a[10] * b12,
        a[3] * b10 + a[7] * b11 + a[11] * b12,
        a[0] * b20 + a[4] * b21 + a[8] * b22,
        a[1] * b20 + a[5] * b21 + a[9] * b22,
        a[2] * b20 + a[6] * b21 + a[10] * b22,
        a[3] * b20 + a[7] * b21 + a[11] * b22,
        ...a.slice(12, 16),
    ];
}

// translate4函数用于平移矩阵
function translate4(a, x, y, z) {
    // 返回平移后的新矩阵
    return [
        ...a.slice(0, 12),
        a[0] * x + a[4] * y + a[8] * z + a[12],
        a[1] * x + a[5] * y + a[9] * z + a[13],
        a[2] * x + a[6] * y + a[10] * z + a[14],
        a[3] * x + a[7] * y + a[11] * z + a[15],
    ];
}

function createWorker(self) {
    let buffer; // 用于存储顶点数据的缓冲区
    let vertexCount = 0; // 顶点计数器
    let viewProj; // 视图投影矩阵
    // 计算每个顶点数据所占的字节长度
    // 6*4 + 4 + 4 = 8*4
    // XYZ - Position (Float32)
    // XYZ - Scale (Float32)
    // RGBA - colors (uint8)
    // IJKL - quaternion/rot (uint8)
    const rowLength = 3 * 4 + 3 * 4 + 4 + 4; // 每行数据的长度
    let lastProj = [];// 上一次的投影矩阵
    let depthIndex = new Uint32Array();// 用于深度排序的索引数组
    let lastVertexCount = 0;// 上一次的顶点计数

    var _floatView = new Float32Array(1);// 用于类型转换的浮点视图
    var _int32View = new Int32Array(_floatView.buffer);// 用于类型转换的整型视图

    // floatToHalf函数将一个浮点数转换为半精度浮点数（16位）
    function floatToHalf(float) {
        _floatView[0] = float; // 将浮点数放入浮点视图
        var f = _int32View[0]; // 通过整型视图获取浮点数的二进制表示

        var sign = (f >> 31) & 0x0001; // 提取符号位
        var exp = (f >> 23) & 0x00ff; // 提取指数位
        var frac = f & 0x007fffff; // 提取尾数位

        var newExp; // 新的指数位
        if (exp == 0) {
            newExp = 0;
        } else if (exp < 113) {
            // 处理非规格化数
            newExp = 0;
            frac |= 0x00800000; // 将尾数的隐含位设置为1
            frac = frac >> (113 - exp); // 右移尾数
            if (frac & 0x01000000) {
                newExp = 1; // 如果尾数溢出，则设置新的指数位
                frac = 0; // 并将尾数清零
            }
        } else if (exp < 142) {
            // 处理规格化数
            newExp = exp - 112; // 调整指数位
        } else {
            // 处理无穷大和NaN
            newExp = 31;
            frac = 0; // 将尾数清零
        }

        // 返回16位的半精度浮点数
        return (sign << 15) | (newExp << 10) | (frac >> 13);
    }
    // packHalf2x16函数将两个浮点数打包成一个32位整数
    function packHalf2x16(x, y) {
        // 分别将x和y转换为半精度浮点数，并将它们合并成一个32位整数
        return (floatToHalf(x) | (floatToHalf(y) << 16)) >>> 0;
    }

    function generateTexture() {
        // 如果没有缓冲区数据，则直接返回
        if (!buffer) return;
        // 将缓冲区数据转换为浮点数数组和无符号字节数组
        const f_buffer = new Float32Array(buffer);
        const u_buffer = new Uint8Array(buffer);

        // 设置纹理的宽度和高度
        var texwidth = 1024 * 2; // 设定期望的宽度
        var texheight = Math.ceil((2 * vertexCount) / texwidth); // 根据顶点数量计算期望的高度
        // 创建纹理数据数组，每个像素包含RGBA四个分量
        var texdata = new Uint32Array(texwidth * texheight * 4); // 4 components per pixel (RGBA)
        // 创建与纹理数据数组共享内存的无符号字节数组和浮点数数组视图
        var texdata_c = new Uint8Array(texdata.buffer);
        var texdata_f = new Float32Array(texdata.buffer);

        // Here we convert from a .splat file buffer into a texture
        // With a little bit more foresight perhaps this texture file
        // should have been the native format as it'd be very easy to
        // load it into webgl.
        // 遍历每个顶点，将.splat文件缓冲区中的数据转换为纹理数据
        for (let i = 0; i < vertexCount; i++) {
            // 提取并设置顶点的位置（x, y, z）
            texdata_f[8 * i + 0] = f_buffer[8 * i + 0];
            texdata_f[8 * i + 1] = f_buffer[8 * i + 1];
            texdata_f[8 * i + 2] = f_buffer[8 * i + 2];

            // 提取并设置顶点的颜色（r, g, b, a）
            texdata_c[4 * (8 * i + 7) + 0] = u_buffer[32 * i + 24 + 0];
            texdata_c[4 * (8 * i + 7) + 1] = u_buffer[32 * i + 24 + 1];
            texdata_c[4 * (8 * i + 7) + 2] = u_buffer[32 * i + 24 + 2];
            texdata_c[4 * (8 * i + 7) + 3] = u_buffer[32 * i + 24 + 3];

            // 提取并计算顶点的缩放和旋转（四元数）
            let scale = [
                f_buffer[8 * i + 3 + 0],
                f_buffer[8 * i + 3 + 1],
                f_buffer[8 * i + 3 + 2],
            ];
            let rot = [
                (u_buffer[32 * i + 28 + 0] - 128) / 128,
                (u_buffer[32 * i + 28 + 1] - 128) / 128,
                (u_buffer[32 * i + 28 + 2] - 128) / 128,
                (u_buffer[32 * i + 28 + 3] - 128) / 128,
            ];

            // 计算缩放矩阵和旋转矩阵的乘积（M = S * R）
            const M = [
                1.0 - 2.0 * (rot[2] * rot[2] + rot[3] * rot[3]),
                2.0 * (rot[1] * rot[2] + rot[0] * rot[3]),
                2.0 * (rot[1] * rot[3] - rot[0] * rot[2]),

                2.0 * (rot[1] * rot[2] - rot[0] * rot[3]),
                1.0 - 2.0 * (rot[1] * rot[1] + rot[3] * rot[3]),
                2.0 * (rot[2] * rot[3] + rot[0] * rot[1]),

                2.0 * (rot[1] * rot[3] + rot[0] * rot[2]),
                2.0 * (rot[2] * rot[3] - rot[0] * rot[1]),
                1.0 - 2.0 * (rot[1] * rot[1] + rot[2] * rot[2]),
            ].map((k, i) => k * scale[Math.floor(i / 3)]);

            // 计算sigma值
            const sigma = [
                M[0] * M[0] + M[3] * M[3] + M[6] * M[6],
                M[0] * M[1] + M[3] * M[4] + M[6] * M[7],
                M[0] * M[2] + M[3] * M[5] + M[6] * M[8],
                M[1] * M[1] + M[4] * M[4] + M[7] * M[7],
                M[1] * M[2] + M[4] * M[5] + M[7] * M[8],
                M[2] * M[2] + M[5] * M[5] + M[8] * M[8],
            ];

            // 使用packHalf2x16函数打包sigma值，并存储到纹理数据中
            texdata[8 * i + 4] = packHalf2x16(4 * sigma[0], 4 * sigma[1]);
            texdata[8 * i + 5] = packHalf2x16(4 * sigma[2], 4 * sigma[3]);
            texdata[8 * i + 6] = packHalf2x16(4 * sigma[4], 4 * sigma[5]);
        }
        // 使用postMessage方法将纹理数据发送回主线程
        self.postMessage({ texdata, texwidth, texheight }, [texdata.buffer]);
    }

    function runSort(viewProj) {
        // 如果没有缓冲区数据，则直接返回
        if (!buffer) return;
        // 将缓冲区数据转换为浮点数数组
        const f_buffer = new Float32Array(buffer);

        // 检查顶点计数是否改变或视图投影矩阵是否变化
        if (lastVertexCount == vertexCount) {
            let dot =
                lastProj[2] * viewProj[2] +
                lastProj[6] * viewProj[6] +
                lastProj[10] * viewProj[10];
            // 如果变化不大，则不需要重新排序
            if (Math.abs(dot - 1) < 0.01) {
                return;
            }
        } else {
            // 如果顶点计数改变，生成新的纹理
            generateTexture();
            lastVertexCount = vertexCount;
        }

        // 开始排序计时
        console.time("sort");
        let maxDepth = -Infinity;
        let minDepth = Infinity;
        let sizeList = new Int32Array(vertexCount);
        // 计算每个顶点的深度值，并找出最大和最小深度
        for (let i = 0; i < vertexCount; i++) {
            let depth =
                ((viewProj[2] * f_buffer[8 * i + 0] +
                    viewProj[6] * f_buffer[8 * i + 1] +
                    viewProj[10] * f_buffer[8 * i + 2]) *
                    4096) |
                0;
            sizeList[i] = depth;
            if (depth > maxDepth) maxDepth = depth;
            if (depth < minDepth) minDepth = depth;
        }

        // 使用16位单通道计数排序
        let depthInv = (256 * 256) / (maxDepth - minDepth);
        let counts0 = new Uint32Array(256 * 256);
        // 计算每个深度值的出现次数
        for (let i = 0; i < vertexCount; i++) {
            sizeList[i] = ((sizeList[i] - minDepth) * depthInv) | 0;
            counts0[sizeList[i]]++;
        }
        // 计算每个深度值的起始索引
        let starts0 = new Uint32Array(256 * 256);
        for (let i = 1; i < 256 * 256; i++)
            starts0[i] = starts0[i - 1] + counts0[i - 1];
        // 根据深度值对顶点索引进行排序
        depthIndex = new Uint32Array(vertexCount);
        for (let i = 0; i < vertexCount; i++)
            depthIndex[starts0[sizeList[i]]++] = i;

        // 结束排序计时
        console.timeEnd("sort");

        // 更新上一次的视图投影矩阵
        lastProj = viewProj;
        // 将排序结果发送回主线程
        self.postMessage({ depthIndex, viewProj, vertexCount }, [
            depthIndex.buffer,
        ]);
    }

    function processPlyBuffer(inputBuffer) {
        // 将输入缓冲区转换为无符号字节数组
        const ubuf = new Uint8Array(inputBuffer);
        // 解码缓冲区的前10KB以获取文件头部信息
        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));
        // 定义头部结束标识
        const header_end = "end_header\n";
        // 查找头部结束标识的位置
        const header_end_index = header.indexOf(header_end);
        // 如果找不到头部结束标识，则抛出错误
        if (header_end_index < 0)
            throw new Error("Unable to read .ply file header");
        // 通过正则表达式匹配，获取顶点数量
        const vertexCount = parseInt(/element vertex (\d+)\n/.exec(header)[1]);
        // 打印顶点数量
        console.log("Vertex Count", vertexCount);
        // 初始化行偏移量、属性偏移量和类型映射
        let row_offset = 0,
            offsets = {},
            types = {};
        // 定义类型到TypedArray方法的映射
        const TYPE_MAP = {
            double: "getFloat64",
            int: "getInt32",
            uint: "getUint32",
            float: "getFloat32",
            short: "getInt16",
            ushort: "getUint16",
            uchar: "getUint8",
        };
        // 遍历头部中的属性定义
        for (let prop of header
            .slice(0, header_end_index)
            .split("\n")
            .filter((k) => k.startsWith("property "))) {
            // 分割属性行以获取类型和名称
            const [p, type, name] = prop.split(" ");
            // 根据类型获取对应的TypedArray方法
            const arrayType = TYPE_MAP[type] || "getInt8";
            // 记录每个属性的类型和偏移量
            types[name] = arrayType;
            offsets[name] = row_offset;
            // 更新行偏移量
            row_offset += parseInt(arrayType.replace(/[^\d]/g, "")) / 8;
        }
        // 打印每行数据的字节数，以及属性类型和偏移量
        console.log("Bytes per row", row_offset, types, offsets);

        // 创建一个DataView来访问缓冲区中的数据
        let dataView = new DataView(
            inputBuffer,
            header_end_index + header_end.length,
        );
        let row = 0;
        // 使用Proxy来动态获取属性值
        const attrs = new Proxy(
            {},
            {
                get(target, prop) {
                    // 如果属性不存在，则抛出错误
                    if (!types[prop]) throw new Error(prop + " not found");
                    // 返回属性值
                    return dataView[types[prop]](
                        row * row_offset + offsets[prop],
                        true,
                    );
                },
            },
        );

        // 计算顶点的重要性
        console.time("calculate importance");
        let sizeList = new Float32Array(vertexCount);
        let sizeIndex = new Uint32Array(vertexCount);
        for (row = 0; row < vertexCount; row++) {
            sizeIndex[row] = row;
            // 如果没有scale_0属性，则跳过
            if (!types["scale_0"]) continue;
            // 计算大小和透明度
            const size =
                Math.exp(attrs.scale_0) *
                Math.exp(attrs.scale_1) *
                Math.exp(attrs.scale_2);
            const opacity = 1 / (1 + Math.exp(-attrs.opacity));
            // 将计算结果存储在sizeList中
            sizeList[row] = size * opacity;
        }
        console.timeEnd("calculate importance");

        // 对顶点索引按重要性进行排序
        console.time("sort");
        sizeIndex.sort((b, a) => sizeList[a] - sizeList[b]);
        console.timeEnd("sort");

        // 6*4 + 4 + 4 = 8*4

        // 定义每行数据的长度
        // XYZ - Position (Float32)
        // XYZ - Scale (Float32)
        // RGBA - colors (uint8)
        // IJKL - quaternion/rot (uint8)
        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;
        // 创建一个新的缓冲区来存储排序后的顶点数据
        const buffer = new ArrayBuffer(rowLength * vertexCount);

        // 开始构建缓冲区的计时
        console.time("build buffer");
        for (let j = 0; j < vertexCount; j++) {
            row = sizeIndex[j]; // 获取排序后的顶点索引

            // 创建TypedArray视图来访问和设置顶点数据
            const position = new Float32Array(buffer, j * rowLength, 3);
            const scales = new Float32Array(buffer, j * rowLength + 4 * 3, 3);
            const rgba = new Uint8ClampedArray(
                buffer,
                j * rowLength + 4 * 3 + 4 * 3,
                4,
            );
            const rot = new Uint8ClampedArray(
                buffer,
                j * rowLength + 4 * 3 + 4 * 3 + 4,
                4,
            );

            // 根据属性类型设置顶点的缩放和旋转
            if (types["scale_0"]) {
                const qlen = Math.sqrt(
                    attrs.rot_0 ** 2 +
                        attrs.rot_1 ** 2 +
                        attrs.rot_2 ** 2 +
                        attrs.rot_3 ** 2,
                );

                rot[0] = (attrs.rot_0 / qlen) * 128 + 128;
                rot[1] = (attrs.rot_1 / qlen) * 128 + 128;
                rot[2] = (attrs.rot_2 / qlen) * 128 + 128;
                rot[3] = (attrs.rot_3 / qlen) * 128 + 128;

                scales[0] = Math.exp(attrs.scale_0);
                scales[1] = Math.exp(attrs.scale_1);
                scales[2] = Math.exp(attrs.scale_2);
            } else {
                // 设置默认值
                scales[0] = 0.01;
                scales[1] = 0.01;
                scales[2] = 0.01;

                rot[0] = 255;
                rot[1] = 0;
                rot[2] = 0;
                rot[3] = 0;
            }
            // 设置顶点的位置
            position[0] = attrs.x;
            position[1] = attrs.y;
            position[2] = attrs.z;

            // 设置顶点的颜色
            if (types["f_dc_0"]) {
                const SH_C0 = 0.28209479177387814;
                rgba[0] = (0.5 + SH_C0 * attrs.f_dc_0) * 255;
                rgba[1] = (0.5 + SH_C0 * attrs.f_dc_1) * 255;
                rgba[2] = (0.5 + SH_C0 * attrs.f_dc_2) * 255;
            } else {
                rgba[0] = attrs.red;
                rgba[1] = attrs.green;
                rgba[2] = attrs.blue;
            }
            // 设置顶点的透明度
            if (types["opacity"]) {
                rgba[3] = (1 / (1 + Math.exp(-attrs.opacity))) * 255;
            } else {
                rgba[3] = 255;
            }
        }
        // 结束构建缓冲区的计时
        console.timeEnd("build buffer");
        return buffer;
    }
    // 定义一个节流排序函数
    const throttledSort = () => {
        // 如果当前没有进行排序
        if (!sortRunning) {
            sortRunning = true; // 标记为正在排序
            let lastView = viewProj; // 记录当前的视图投影矩阵
            runSort(lastView); // 执行排序
            // 设置延时以控制排序频率
            setTimeout(() => {
                sortRunning = false; // 标记为排序完成
                // 如果视图投影矩阵已更改，则再次执行排序
                if (lastView !== viewProj) {
                    throttledSort();
                }
            }, 0);
        }
    };

    // sortRunning用于标记是否有排序操作正在执行
    let sortRunning;
    // self.onmessage用于处理从主线程接收到的消息
    self.onmessage = (e) => {
        if (e.data.ply) {
            // 如果收到PLY数据，处理PLY文件并生成缓冲区
            vertexCount = 0;
            runSort(viewProj);
            buffer = processPlyBuffer(e.data.ply);
            vertexCount = Math.floor(buffer.byteLength / rowLength);
            postMessage({ buffer: buffer });
        } else if (e.data.buffer) {
            // 如果收到缓冲区数据，更新缓冲区和顶点计数
            buffer = e.data.buffer;
            vertexCount = e.data.vertexCount;
        } else if (e.data.vertexCount) {
            // 如果只收到顶点计数，更新顶点计数
            vertexCount = e.data.vertexCount;
        } else if (e.data.view) {
            // 如果收到视图投影矩阵，执行节流排序
            viewProj = e.data.view;
            throttledSort();
        }
    };
}
// 以下是WebGL顶点着色器的源代码
const vertexShaderSource = `
#version 300 es
precision highp float;
precision highp int;

// 定义着色器的uniform变量和输入变量
uniform highp usampler2D u_texture;
uniform mat4 projection, view;
uniform vec2 focal;
uniform vec2 viewport;

in vec2 position;
in int index;

// 定义着色器的输出变量
out vec4 vColor;
out vec2 vPosition;

void main () {
    // 从纹理中获取顶点数据
    uvec4 cen = texelFetch(u_texture, ivec2((uint(index) & 0x3ffu) << 1, uint(index) >> 10), 0);
    // 计算顶点在摄像机空间中的位置
    vec4 cam = view * vec4(uintBitsToFloat(cen.xyz), 1);
    // 将顶点位置转换为屏幕空间坐标
    vec4 pos2d = projection * cam;
    
    // 裁剪和渲染顶点的代码
    float clip = 1.2 * pos2d.w;
    if (pos2d.z < -clip || pos2d.x < -clip || pos2d.x > clip || pos2d.y < -clip || pos2d.y > clip) {
        gl_Position = vec4(0.0, 0.0, 2.0, 1.0);
        return;
    }
    // 裁剪和渲染顶点的代码
    uvec4 cov = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 1) | 1u, uint(index) >> 10), 0);
    vec2 u1 = unpackHalf2x16(cov.x), u2 = unpackHalf2x16(cov.y), u3 = unpackHalf2x16(cov.z);
    mat3 Vrk = mat3(u1.x, u1.y, u2.x, u1.y, u2.y, u3.x, u2.x, u3.x, u3.y);

    mat3 J = mat3(
        focal.x / cam.z, 0., -(focal.x * cam.x) / (cam.z * cam.z), 
        0., -focal.y / cam.z, (focal.y * cam.y) / (cam.z * cam.z), 
        0., 0., 0.
    );

    mat3 T = transpose(mat3(view)) * J;
    mat3 cov2d = transpose(T) * Vrk * T;

    float mid = (cov2d[0][0] + cov2d[1][1]) / 2.0;
    float radius = length(vec2((cov2d[0][0] - cov2d[1][1]) / 2.0, cov2d[0][1]));
    float lambda1 = mid + radius, lambda2 = mid - radius;

    if(lambda2 < 0.0) return;
    vec2 diagonalVector = normalize(vec2(cov2d[0][1], lambda1 - cov2d[0][0]));
    vec2 majorAxis = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;
    vec2 minorAxis = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);

    // 计算顶点的颜色和位置
    vColor = clamp(pos2d.z/pos2d.w+1.0, 0.0, 1.0) * vec4((cov.w) & 0xffu, (cov.w >> 8) & 0xffu, (cov.w >> 16) & 0xffu, (cov.w >> 24) & 0xffu) / 255.0;
    vPosition = position;
    
    // 顶点位置计算的代码
    vec2 vCenter = vec2(pos2d) / pos2d.w;
    gl_Position = vec4(
        vCenter 
        + position.x * majorAxis / viewport 
        + position.y * minorAxis / viewport, 0.0, 1.0);

}
`.trim();

// WebGL片元着色器源代码
const fragmentShaderSource = `
#version 300 es
precision highp float;

// 输入变量：顶点着色器传递的颜色和位置
in vec4 vColor;
in vec2 vPosition;

// 输出变量：片元的颜色
out vec4 fragColor;

void main () {
    // 计算位置向量的平方长度的负值
    float A = -dot(vPosition, vPosition);
    // 如果A小于-4.0，则丢弃这个片元，不进行绘制
    if (A < -4.0) discard;
    // 计算颜色的alpha值和指数函数的乘积
    float B = exp(A) * vColor.a;
    // 设置片元的颜色，包括RGB和alpha（透明度）
    fragColor = vec4(B * vColor.rgb, B);
}

`.trim();

// 默认的视图矩阵
let defaultViewMatrix = [0.59,-0.12,0.8,0,0.61,0.72,-0.33,0,-0.54,0.69,0.5,0,-1.24,-0.33,4.32,1];
// 实际使用的视图矩阵
let viewMatrix = defaultViewMatrix;
    // 轮播标志，默认为trues
    let carousel = true;
function changeViewAnimation(startPos, endPos, duration) {
    console.log(111)
    const startTime = Date.now();
    const endTime = startTime + duration;

    function animate() {
        const currentTime = Date.now();
        const elapsedTime = currentTime - startTime;
        const t = Math.min(1, elapsedTime / duration); // 归一化时间，确保t在0到1之间

        if (currentTime < endTime) {
            // 更新视图矩阵
            viewMatrix = getCameraPositionAtTime(startPos, endPos, t);
            console.log('函数执行了 ' + elapsedTime + ' 毫秒');

            // 继续动画循环
            requestAnimationFrame(animate);
        } else {
            // 动画结束，设置最终的视图矩阵
            viewMatrix = getCameraPositionAtTime(startPos, endPos, 1); // t=1 表示动画结束
            console.log('动画完成');
        }
    }

    // 开始动画循环
    requestAnimationFrame(animate);
}
// 主函数
async function renderer() {

    // 解析URL参数
    const params = new URLSearchParams(location.search);
    try {
        // 尝试从URL哈希中获取视图矩阵
        viewMatrix = JSON.parse(decodeURIComponent(location.hash.slice(1)));
        // 如果成功获取，则关闭轮播
        carousel = false;
    } catch (err) {}

    // 构建请求的URL
    const url = new URL(
        // "nike.splat",
        // location.href,
        params.get("url") ||  "kongzi.splat",
        // "https://huggingface.co/cakewalk/splat-data/resolve/main/",
        // "library.splat""model.splat"
        // "https://huggingface.co/zhixinxie5548/Splat-data/resolve/main/"
        "https://9284.kstore.space/model/"
        // "https://mp-c6b0c393-d043-4458-893d-fa305217118a.cdn.bspapp.com/test/"
    );
    // 发起请求
    const req = await fetch(url, {
        mode: "cors", // no-cors, *cors, same-origin
        credentials: "omit", // include, *same-origin, omit
    });
    console.log(req);
    // 如果请求失败，抛出错误
    if (req.status != 200)
        throw new Error(req.status + " Unable to load " + req.url);

    // 计算每行数据的长度
    const rowLength = 3 * 4 + 3 * 4 + 4 + 4;
    // 获取响应体的阅读器
    const reader = req.body.getReader();
    // 创建一个Uint8Array来存储splat数据
    let splatData = new Uint8Array(req.headers.get("content-length"));

    // 根据数据量决定是否降采样
    const downsample =
        splatData.length / rowLength > 500000 ? 1 : 1 / devicePixelRatio;
    console.log(splatData.length / rowLength, downsample);

    // 创建一个Web Worker来处理数据
    const worker = new Worker(
        URL.createObjectURL(
            new Blob(["(", createWorker.toString(), ")(self)"], {
                type: "application/javascript",
            }),
        ),
    );

    // 获取canvas元素和相关DOM元素
    const canvas = document.getElementById("canvas");
    const fps = document.getElementById("fps");
    const camid = document.getElementById("camid");

    // 初始化投影矩阵
    let projectionMatrix;

    // 获取WebGL2上下文
    const gl = canvas.getContext("webgl2", {
        antialias: false,
    });

    // 创建一个顶点着色器对象
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    // 将GLSL源代码关联到顶点着色器
    gl.shaderSource(vertexShader, vertexShaderSource);
    // 编译顶点着色器
    gl.compileShader(vertexShader);
    // 检查顶点着色器是否编译成功
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(vertexShader));

    // 创建一个片元着色器对象
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    // 将GLSL源代码关联到片元着色器
    gl.shaderSource(fragmentShader, fragmentShaderSource);
    // 编译片元着色器
    gl.compileShader(fragmentShader);
    // 检查片元着色器是否编译成功
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(fragmentShader));

    // 创建一个着色器程序
    const program = gl.createProgram();
    // 将顶点着色器附加到程序
    gl.attachShader(program, vertexShader);
    // 将片元着色器附加到程序
    gl.attachShader(program, fragmentShader);
    // 链接着色器程序
    gl.linkProgram(program);
    // 使用着色器程序
    gl.useProgram(program);

    // 检查着色器程序是否链接成功
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
        console.error(gl.getProgramInfoLog(program));

    // 禁用深度测试
    gl.disable(gl.DEPTH_TEST);

    // 启用混合模式
    gl.enable(gl.BLEND);
    // 设置混合函数
    gl.blendFuncSeparate(
        gl.ONE_MINUS_DST_ALPHA,
        gl.ONE,
        gl.ONE_MINUS_DST_ALPHA,
        gl.ONE,
    );
    // 设置混合方程式
    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);

    // 获取uniform变量的位置
    const u_projection = gl.getUniformLocation(program, "projection");
    const u_viewport = gl.getUniformLocation(program, "viewport");
    const u_focal = gl.getUniformLocation(program, "focal");
    const u_view = gl.getUniformLocation(program, "view");

    // 定义顶点数据
    const triangleVertices = new Float32Array([-2, -2, 2, -2, 2, 2, -2, 2]);
    // 创建一个缓冲区对象
    const vertexBuffer = gl.createBuffer();
    // 绑定缓冲区对象
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    // 向缓冲区对象中写入数据
    gl.bufferData(gl.ARRAY_BUFFER, triangleVertices, gl.STATIC_DRAW);
    // 获取attribute变量的位置
    const a_position = gl.getAttribLocation(program, "position");
    // 启用attribute变量
    gl.enableVertexAttribArray(a_position);
    // 绑定缓冲区对象
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    // 指定attribute变量如何从缓冲区读取数据
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

    // 创建一个纹理对象
    var texture = gl.createTexture();
    // 绑定纹理对象
    gl.bindTexture(gl.TEXTURE_2D, texture);

    // 获取uniform变量u_texture的位置
    var u_textureLocation = gl.getUniformLocation(program, "u_texture");
    // 将纹理单元编号传递给着色器中的u_texture
    gl.uniform1i(u_textureLocation, 0);

    // 创建一个缓冲区对象用于索引
    const indexBuffer = gl.createBuffer();
    // 获取attribute变量index的位置
    const a_index = gl.getAttribLocation(program, "index");
    // 启用attribute变量
    gl.enableVertexAttribArray(a_index);
    // 绑定缓冲区对象
    gl.bindBuffer(gl.ARRAY_BUFFER, indexBuffer);
    // 指定attribute变量如何从缓冲区读取数据
    gl.vertexAttribIPointer(a_index, 1, gl.INT, false, 0, 0);
    // 设置attribute变量在绘制数组实例时的增量
    gl.vertexAttribDivisor(a_index, 1);


    // 定义一个函数来处理画布大小调整
    const resize = () => {
        // 更新焦距长度的uniform值
        gl.uniform2fv(u_focal, new Float32Array([camera.fx, camera.fy]));

        // 根据相机的焦距和窗口大小计算新的投影矩阵
        projectionMatrix = getProjectionMatrix(
            camera.fx,
            camera.fy,
            innerWidth,
            innerHeight,
        );

        // 更新视口的uniform值
        gl.uniform2fv(u_viewport, new Float32Array([innerWidth, innerHeight]));

        // 设置画布大小，根据下采样率调整
        gl.canvas.width = Math.round(innerWidth / downsample);
        gl.canvas.height = Math.round(innerHeight / downsample);
        // 设置WebGL视口以匹配新的画布大小
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        // 更新投影矩阵的uniform
        gl.uniformMatrix4fv(u_projection, false, projectionMatrix);
    };

    // 添加事件监听器来处理窗口大小调整事件
    window.addEventListener("resize", resize);
    // 调用resize函数设置初始大小
    resize();

    // 处理从Web Worker接收到的消息
    worker.onmessage = (e) => {
        if (e.data.buffer) {
            // 如果接收到缓冲区，创建Blob并触发下载
            splatData = new Uint8Array(e.data.buffer);
            const blob = new Blob([splatData.buffer], {
                type: "application/octet-stream",
            });
            const link = document.createElement("a");
            link.download = "model.splat";
            link.href = URL.createObjectURL(blob);
            document.body.appendChild(link);
            link.click();
        } else if (e.data.texdata) {
            // 如果接收到纹理数据，更新WebGL纹理
            const { texdata, texwidth, texheight } = e.data;
            // console.log(texdata)
            gl.bindTexture(gl.TEXTURE_2D, texture);
            // 设置纹理参数
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_WRAP_S,
                gl.CLAMP_TO_EDGE,
            );
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_WRAP_T,
                gl.CLAMP_TO_EDGE,
            );
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            // 定义2D纹理图像
            gl.texImage2D(
                gl.TEXTURE_2D,
                0,
                gl.RGBA32UI,
                texwidth,
                texheight,
                0,
                gl.RGBA_INTEGER,
                gl.UNSIGNED_INT,
                texdata,
            );
            // 激活纹理单元并绑定纹理
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
        } else if (e.data.depthIndex) {
            // 如果接收到深度索引数据，使用新数据更新缓冲区
            const { depthIndex, viewProj } = e.data;
            gl.bindBuffer(gl.ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, depthIndex, gl.DYNAMIC_DRAW);
            // 更新顶点计数
            vertexCount = e.data.vertexCount;
        }
    };


    // 添加键盘按下事件监听器
    window.addEventListener("keydown", (e) => {
        // 如果按下的键不在激活键数组中，则添加进去
        if (!activeKeys.includes(e.code)) activeKeys.push(e.code);
        // 如果按下的是数字键，则切换到对应的相机视角
        if (/\d/.test(e.key)) {
            // currentCameraIndex = parseInt(e.key)
            // camera = cameras[currentCameraIndex];
            // viewMatrix = getViewMatrix(camera);
            carousel = false;
            currentCameraIndex = parseInt(e.key)
            camstart = viewMatrix
            camend = cams[currentCameraIndex]
            // 调用函数以3秒的持续时间开始动画
            changeViewAnimation(camstart,camend,5000);
        }
        // 如果按下的是'-'或'_'键，则切换到上一个相机视角
		if (['-', '_'].includes(e.key)){
			currentCameraIndex = (currentCameraIndex + cams.length - 1) % cams.length;
            carousel = false;
            currentCameraIndex = parseInt(e.key)
            camstart = viewMatrix
            camend = cams[currentCameraIndex]
            // 调用函数以3秒的持续时间开始动画
            changeViewAnimation(camstart,camend,5000);
		}
		// 如果按下的是'+'或'='键，则切换到下一个相机视角
		if (['+', '='].includes(e.key)){
			currentCameraIndex = (currentCameraIndex + 1) % cams.length;
			carousel = false;
            currentCameraIndex = parseInt(e.key)
            camstart = viewMatrix
            camend = cams[currentCameraIndex]
            // 调用函数以3秒的持续时间开始动画
            changeViewAnimation(camstart,camend,5000);
		}
		// 更新相机索引显示
        camid.innerText = "cam  " + currentCameraIndex;
        // 如果按下的是'V'键，则将当前视图矩阵保存到URL的哈希中
        if (e.code === "KeyV") {
            location.hash =
                "#" +
                JSON.stringify(
                    viewMatrix.map((k) => Math.round(k * 100) / 100),
                );
                camid.innerText =""
        // 如果按下的是'P'键，则开启或关闭轮播模式
        } else if (e.code === "KeyP") {
            carousel = true;
            camid.innerText =""
        } else if(e.code === "KeyT"){
            // 调用函数以3秒的持续时间开始动画
            // changeViewAnimation(cam1,cam2,3000);
            // console.log(cam)
        }
    });
    // 添加键盘松开事件监听器
    window.addEventListener("keyup", (e) => {
        // 从激活键数组中移除松开的键
        activeKeys = activeKeys.filter((k) => k !== e.code);
    });
    // 添加窗口失焦事件监听器
    window.addEventListener("blur", () => {
        // 清空激活键数组
        activeKeys = [];
    });

    // 添加鼠标滚轮事件监听器
    window.addEventListener(
        "wheel",
        (e) => {
            // 阻止默认滚动行为
            carousel = false;
            e.preventDefault();
            // 根据滚动模式设置缩放比例
            const lineHeight = 10;
            const scale =
                e.deltaMode == 1
                    ? lineHeight
                    : e.deltaMode == 2
                    ? innerHeight
                    : 1;
            // 获取当前视图矩阵的逆矩阵
            let inv = invert4(viewMatrix);
            // 根据滚轮的移动和按键状态，计算新的视图矩阵
            if (e.shiftKey) {
                // 如果按下Shift键，进行平移操作
                inv = translate4(
                    inv,
                    (e.deltaX * scale) / innerWidth,
                    (e.deltaY * scale) / innerHeight,
                    0,
                );
            } else if (e.ctrlKey || e.metaKey) {
                // 如果按下Ctrl键或Meta键，进行深度平移操作
                // inv = rotate4(inv,  (e.deltaX * scale) / innerWidth,  0, 0, 1);
                // inv = translate4(inv,  0, (e.deltaY * scale) / innerHeight, 0);
                // let preY = inv[13];
                inv = translate4(
                    inv,
                    0,
                    0,
                    (-10 * (e.deltaY * scale)) / innerHeight,
                );
                // inv[13] = preY;
            } else {
                // 否则，进行旋转操作
                let d = 4;
                inv = translate4(inv, 0, 0, d);
                inv = rotate4(inv, -(e.deltaX * scale) / innerWidth, 0, 1, 0);
                inv = rotate4(inv, (e.deltaY * scale) / innerHeight, 1, 0, 0);
                inv = translate4(inv, 0, 0, -d);
            }
            // 将计算出的逆矩阵再次求逆，得到新的视图矩阵
            viewMatrix = invert4(inv);
        },
        { passive: false },
    );

    // 初始化变量，用于跟踪鼠标按下的位置和状态
    let startX, startY, down;

    // 当鼠标按下时触发的事件
    canvas.addEventListener("mousedown", (e) => {
        carousel = false; // 停止任何自动旋转
        e.preventDefault(); // 阻止默认事件
        startX = e.clientX; // 记录鼠标按下的X坐标
        startY = e.clientY; // 记录鼠标按下的Y坐标
        down = e.ctrlKey || e.metaKey ? 2 : 1; // 根据是否按下Ctrl或Meta键设置模式
    });

    // 当鼠标右键点击时触发的事件
    canvas.addEventListener("contextmenu", (e) => {
        carousel = false; // 停止任何自动旋转
        e.preventDefault(); // 阻止默认事件
        startX = e.clientX; // 记录鼠标按下的X坐标
        startY = e.clientY; // 记录鼠标按下的Y坐标
        down = 2; // 设置为平移模式
    });

    // 当鼠标移动时触发的事件
    canvas.addEventListener("mousemove", (e) => {
        e.preventDefault(); // 阻止默认事件
        if (down == 1) {
            // 如果是旋转模式
            let inv = invert4(viewMatrix); // 获取当前视图矩阵的逆矩阵
            let dx = (5 * (e.clientX - startX)) / innerWidth; // 计算X方向的旋转量
            let dy = (5 * (e.clientY - startY)) / innerHeight; // 计算Y方向的旋转量
            let d = 4; // 设置旋转半径

            // 应用旋转和平移变换
            inv = translate4(inv, 0, 0, d);
            inv = rotate4(inv, dx, 0, 1, 0);
            inv = rotate4(inv, -dy, 1, 0, 0);
            inv = translate4(inv, 0, 0, -d);
            // let postAngle = Math.atan2(inv[0], inv[10])
            // inv = rotate4(inv, postAngle - preAngle, 0, 0, 1)
            // console.log(postAngle)
            viewMatrix = invert4(inv); // 更新视图矩阵

            startX = e.clientX; // 更新鼠标位置
            startY = e.clientY;
        } else if (down == 2) {
            // 如果是平移模式
            let inv = invert4(viewMatrix); // 获取当前视图矩阵的逆矩阵
            // inv = rotateY(inv, );
            // let preY = inv[13];
            // 应用平移变换
            inv = translate4(
                inv,
                (-10 * (e.clientX - startX)) / innerWidth,
                0,
                (10 * (e.clientY - startY)) / innerHeight,
            );
            // inv[13] = preY;
            viewMatrix = invert4(inv); // 更新视图矩阵

            startX = e.clientX; // 更新鼠标位置
            startY = e.clientY;
        }
    });

    // 当鼠标松开时触发的事件
    canvas.addEventListener("mouseup", (e) => {
        e.preventDefault(); // 阻止默认事件
        down = false; // 重置鼠标状态
        startX = 0; // 重置鼠标位置
        startY = 0;
    });

    // 初始化变量，用于跟踪触摸点的位置
    let altX = 0,
        altY = 0;

    // 添加触摸开始事件监听器
    canvas.addEventListener(
        "touchstart",
        (e) => {
            e.preventDefault(); // 阻止默认事件
            if (e.touches.length === 1) {
                carousel = false; // 停止任何自动旋转
                startX = e.touches[0].clientX; // 记录第一个触摸点的X坐标
                startY = e.touches[0].clientY; // 记录第一个触摸点的Y坐标
                down = 1; // 设置为旋转模式
            } else if (e.touches.length === 2) {
                // console.log('beep')
                carousel = false; // 停止任何自动旋转
                startX = e.touches[0].clientX; // 记录第一个触摸点的X坐标
                altX = e.touches[1].clientX; // 记录第二个触摸点的X坐标
                startY = e.touches[0].clientY; // 记录第一个触摸点的Y坐标
                altY = e.touches[1].clientY; // 记录第二个触摸点的Y坐标
                down = 1; // 设置为旋转模式
            }
        },
        { passive: false },
    );

    // 添加触摸移动事件监听器
    canvas.addEventListener(
        "touchmove",
        (e) => {
            e.preventDefault(); // 阻止默认事件
            if (e.touches.length === 1 && down) {
                let inv = invert4(viewMatrix); // 获取当前视图矩阵的逆矩阵
                let dx = (4 * (e.touches[0].clientX - startX)) / innerWidth; // 计算X方向的旋转量
                let dy = (4 * (e.touches[0].clientY - startY)) / innerHeight; // 计算Y方向的旋转量

                let d = 4; // 设置旋转半径
                inv = translate4(inv, 0, 0, d); // 应用平移变换
                // inv = translate4(inv,  -x, -y, -z);
                // inv = translate4(inv,  x, y, z);
                inv = rotate4(inv, dx, 0, 1, 0); // 应用X方向的旋转变换
                inv = rotate4(inv, -dy, 1, 0, 0); // 应用Y方向的旋转变换
                inv = translate4(inv, 0, 0, -d); // 应用平移变换

                viewMatrix = invert4(inv); // 更新视图矩阵

                startX = e.touches[0].clientX; // 更新触摸点位置
                startY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // 如果有两个触摸点
                // alert('beep')
                const dtheta =
                    Math.atan2(startY - altY, startX - altX) -
                    Math.atan2(
                        e.touches[0].clientY - e.touches[1].clientY,
                        e.touches[0].clientX - e.touches[1].clientX,
                    ); // 计算旋转角度
                const dscale =
                    Math.hypot(startX - altX, startY - altY) /
                    Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY,
                    ); // 计算缩放比例
                const dx =
                    (e.touches[0].clientX +
                        e.touches[1].clientX -
                        (startX + altX)) /
                    2; // 计算X方向的平移量
                const dy =
                    (e.touches[0].clientY +
                        e.touches[1].clientY -
                        (startY + altY)) /
                    2; // 计算Y方向的平移量
                let inv = invert4(viewMatrix); // 获取当前视图矩阵的逆矩阵
                // inv = translate4(inv,  0, 0, d);
                inv = rotate4(inv, dtheta, 0, 0, 1); // 应用Z方向的旋转变换

                inv = translate4(inv, -dx / innerWidth, -dy / innerHeight, 0); // 应用平移变换

                // let preY = inv[13];
                inv = translate4(inv, 0, 0, 3 * (1 - dscale)); // 应用深度方向的平移变换
                // inv[13] = preY;

                viewMatrix = invert4(inv); // 更新视图矩阵

                startX = e.touches[0].clientX; // 更新触摸点位置
                altX = e.touches[1].clientX;
                startY = e.touches[0].clientY;
                altY = e.touches[1].clientY;
            }
        },
        { passive: false },
    );

    // 添加触摸结束事件监听器
    canvas.addEventListener(
        "touchend",
        (e) => {
            e.preventDefault(); // 阻止默认事件
            down = false; // 重置触摸状态
            startX = 0; // 重置触摸点位置
            startY = 0;
        },
        { passive: false },
    );

    // 初始化变量
    let jumpDelta = 0;
    let vertexCount = 0;

    let lastFrame = 0;
    let avgFps = 0;
    let start = 0;

    // 监听游戏手柄连接事件
    window.addEventListener("gamepadconnected", (e) => {
        const gp = navigator.getGamepads()[e.gamepad.index];
        console.log(
            `Gamepad connected at index ${gp.index}: ${gp.id}. It has ${gp.buttons.length} buttons and ${gp.axes.length} axes.`,
        );
    });
    // 监听游戏手柄断开连接事件
    window.addEventListener("gamepaddisconnected", (e) => {
        console.log("Gamepad disconnected");
    });

    let leftGamepadTrigger, rightGamepadTrigger;

    // 定义每一帧的处理函数
    const frame = (now) => {
        let inv = invert4(viewMatrix); // 获取当前视图矩阵的逆矩阵
        // 检查是否按下Shift键
        let shiftKey = activeKeys.includes("Shift") || activeKeys.includes("ShiftLeft") || activeKeys.includes("ShiftRight");

        // 根据按下的箭头键进行平移操作
        if (activeKeys.includes("ArrowUp")) {
            if (shiftKey) {
                inv = translate4(inv, 0, -0.03, 0);
            } else {
                inv = translate4(inv, 0, 0, 0.1);
            }
        }
        if (activeKeys.includes("ArrowDown")) {
            if (shiftKey) {
                inv = translate4(inv, 0, 0.03, 0);
            } else {
                inv = translate4(inv, 0, 0, -0.1);
            }
        }
        if (activeKeys.includes("ArrowLeft"))
            inv = translate4(inv, -0.03, 0, 0);
        //
        if (activeKeys.includes("ArrowRight"))
            inv = translate4(inv, 0.03, 0, 0);
        // inv = rotate4(inv, 0.01, 0, 1, 0);
        // 根据按下的字母键进行旋转操作
        if (activeKeys.includes("KeyA")) inv = rotate4(inv, -0.01, 0, 1, 0);
        if (activeKeys.includes("KeyD")) inv = rotate4(inv, 0.01, 0, 1, 0);
        if (activeKeys.includes("KeyQ")) inv = rotate4(inv, 0.01, 0, 0, 1);
        if (activeKeys.includes("KeyE")) inv = rotate4(inv, -0.01, 0, 0, 1);
        if (activeKeys.includes("KeyW")) inv = rotate4(inv, 0.005, 1, 0, 0);
        if (activeKeys.includes("KeyS")) inv = rotate4(inv, -0.005, 1, 0, 0);

        // 获取连接的游戏手柄列表
        const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
        let isJumping = activeKeys.includes("Space");
        for (let gamepad of gamepads) {
            if (!gamepad) continue;

            const axisThreshold = 0.1; // 用于检测轴是否有意移动的阈值
            const moveSpeed = 0.06; // 移动速度
            const rotateSpeed = 0.02; // 旋转速度

            // 假设左摇杆控制平移（轴0和轴1）
            if (Math.abs(gamepad.axes[0]) > axisThreshold) {
                inv = translate4(inv, moveSpeed * gamepad.axes[0], 0, 0);
                carousel = false;
            }
            if (Math.abs(gamepad.axes[1]) > axisThreshold) {
                inv = translate4(inv, 0, 0, -moveSpeed * gamepad.axes[1]);
                carousel = false;
            }
            // 处理游戏手柄上的按钮按下事件，进行平移操作
            if(gamepad.buttons[12].pressed || gamepad.buttons[13].pressed){
                inv = translate4(inv, 0, -moveSpeed*(gamepad.buttons[12].pressed - gamepad.buttons[13].pressed), 0);
                carousel = false;
            }

            if(gamepad.buttons[14].pressed || gamepad.buttons[15].pressed){
                inv = translate4(inv, -moveSpeed*(gamepad.buttons[14].pressed - gamepad.buttons[15].pressed), 0, 0);
                carousel = false;
            }

            // 假设右摇杆控制旋转（轴2和轴3）
            if (Math.abs(gamepad.axes[2]) > axisThreshold) {
                // 如果轴2的绝对值大于阈值，则根据轴2的值旋转视角
                inv = rotate4(inv, rotateSpeed * gamepad.axes[2], 0, 1, 0);
                carousel = false; // 停止旋转展示模式
            }
            if (Math.abs(gamepad.axes[3]) > axisThreshold) {
                // 如果轴3的绝对值大于阈值，则根据轴3的值旋转视角
                inv = rotate4(inv, -rotateSpeed * gamepad.axes[3], 1, 0, 0);
                carousel = false; // 停止旋转展示模式
            }

            // 处理游戏手柄的倾斜操作
            let tiltAxis = gamepad.buttons[6].value - gamepad.buttons[7].value;
            if (Math.abs(tiltAxis) > axisThreshold) {
                // 如果倾斜轴的绝对值大于阈值，则根据倾斜轴的值旋转视角
                inv = rotate4(inv, rotateSpeed * tiltAxis, 0, 0, 1);
                carousel = false; // 停止旋转展示模式
            }

            // 处理游戏手柄的按钮输入，切换相机视角
            if (gamepad.buttons[4].pressed && !leftGamepadTrigger) {
                // 如果按下左侧手柄的按钮4且之前未按下，则切换到下一个相机视角
                camera = cameras[(cameras.indexOf(camera)+1)%cameras.length]
                inv = invert4(getViewMatrix(camera));
                carousel = false; // 停止旋转展示模式
            }
            if (gamepad.buttons[5].pressed && !rightGamepadTrigger) {
                // 如果按下右侧手柄的按钮5且之前未按下，则切换到上一个相机视角
                camera = cameras[(cameras.indexOf(camera)+cameras.length-1)%cameras.length]
                inv = invert4(getViewMatrix(camera));
                carousel = false; // 停止旋转展示模式
            }

            // 更新手柄按钮的状态
            leftGamepadTrigger = gamepad.buttons[4].pressed;
            rightGamepadTrigger = gamepad.buttons[5].pressed;

            // 处理跳跃操作
            if (gamepad.buttons[0].pressed) {
                isJumping = true; // 开始跳跃
                carousel = false; // 停止旋转展示模式
            }

            // 如果按下手柄的按钮3，则开启旋转展示模式
            if(gamepad.buttons[3].pressed){
                carousel = true;
            }
        }
        // 如果按下键盘的J、K、L、I中的任意键，则进行平移和旋转操作
        if (
            ["KeyJ", "KeyK", "KeyL", "KeyI"].some((k) => activeKeys.includes(k))
        ) {
            let d = 4;
            // 平移视角
            inv = translate4(inv, 0, 0, d);
            // 根据按下的键进行旋转
            inv = rotate4(
                inv,
                activeKeys.includes("KeyJ")
                    ? -0.05
                    : activeKeys.includes("KeyL")
                    ? 0.05
                    : 0,
                0,
                1,
                0,
            );
            inv = rotate4(
                inv,
                activeKeys.includes("KeyI")
                    ? 0.05
                    : activeKeys.includes("KeyK")
                    ? -0.05
                    : 0,
                1,
                0,
                0,
            );
            // 平移回原位
            inv = translate4(inv, 0, 0, -d);
        }

        // 反转矩阵以获取最终的视图矩阵
        viewMatrix = invert4(inv);

        // 如果处于旋转展示模式，则根据时间进行旋转和平移
        if (carousel) {
            let inv = invert4(defaultViewMatrix);

            // 根据时间计算旋转和平移的参数
            // const t = Math.sin((Date.now() - start) / 5000);
            // inv = translate4(inv, 2.5 * t, 0, 6 * (1 - Math.cos(t)));
            // inv = rotate4(inv, -0.6 * t, 0, 1, 0);
            const t = Math.sin((Date.now() - start) / 5000);
            inv = translate4(inv, 0.1 * t, 0, 0);
            inv = rotate4(inv, -0.1 * t, 0, 1, 0);
            // 反转矩阵以获取最终的视图矩阵
            viewMatrix = invert4(inv);
        }
        // 如果角色处于跳跃状态
        if (isJumping) {
            // 增加跳跃的增量值，但不超过1
            jumpDelta = Math.min(1, jumpDelta + 0.05);
        } else {
            // 减少跳跃的增量值，但不低于0
            jumpDelta = Math.max(0, jumpDelta - 0.05);
        }

        // 反转视图矩阵，准备进行变换
        let inv2 = invert4(viewMatrix);
        // 根据跳跃的增量值在Y轴方向进行平移
        inv2 = translate4(inv2, 0, -jumpDelta, 0);
        // 根据跳跃的增量值在X轴方向进行旋转
        inv2 = rotate4(inv2, -0.1 * jumpDelta, 1, 0, 0);
        // 反转矩阵，得到实际的视图矩阵
        let actualViewMatrix = invert4(inv2);

        // 将视图矩阵与投影矩阵相乘，得到视图投影矩阵
        const viewProj = multiply4(projectionMatrix, actualViewMatrix);
        // 将视图投影矩阵发送给工作线程
        worker.postMessage({ view: viewProj });

        // 计算当前帧率
        const currentFps = 1000 / (now - lastFrame) || 0;
        // 计算平均帧率
        avgFps = avgFps * 0.9 + currentFps * 0.1;

        // 如果顶点数量大于0
        if (vertexCount > 0) {
            // 隐藏加载指示器
            document.getElementById("spinner").style.display = "none";
            // 更新着色器中的视图矩阵
            gl.uniformMatrix4fv(u_view, false, actualViewMatrix);
            // 清除颜色缓冲区
            gl.clear(gl.COLOR_BUFFER_BIT);
            // 绘制实例化的三角形扇
            gl.drawArraysInstanced(gl.TRIANGLE_FAN, 0, 4, vertexCount);
        } else {
            // 清除颜色缓冲区
            gl.clear(gl.COLOR_BUFFER_BIT);
            // 显示加载指示器
            document.getElementById("spinner").style.display = "";
            // 设置开始时间
            start = Date.now() + 2000;
        }

        // 计算加载进度
        const progress = (100 * vertexCount) / (splatData.length / rowLength);
        // 如果进度小于100%
        if (progress < 100) {
            // 更新进度条宽度
            document.getElementById("progress").style.width = progress + "%";
        } else {
            // 隐藏进度条
            document.getElementById("progress").style.display = "none";
        }

        // 显示当前帧率
        fps.innerText = Math.round(avgFps) + " fps";
        // 如果当前相机索引不是数字，则清空相机ID文本
        if (isNaN(currentCameraIndex)){
            camid.innerText = "";
        }

        // 更新上一帧的时间
        lastFrame = now;
        // 请求下一帧的动画
        requestAnimationFrame(frame);
    };
    // 开始帧动画
    frame();

    // 定义选择文件的函数
    const selectFile = (file) => {
        const fr = new FileReader();
        // 检查文件名是否以.json结尾
        if (/\.json$/i.test(file.name)) {
            fr.onload = () => {
                // 解析JSON文件并设置相机和投影矩阵
                cameras = JSON.parse(fr.result);
                viewMatrix = getViewMatrix(cameras[0]);
                projectionMatrix = getProjectionMatrix(
                    camera.fx / downsample,
                    camera.fy / downsample,
                    canvas.width,
                    canvas.height,
                );
                // 将投影矩阵传递给着色器
                gl.uniformMatrix4fv(u_projection, false, projectionMatrix);

                console.log("Loaded Cameras");
            };
            // 读取文本文件
            fr.readAsText(file);
        } else {
            // 如果不是JSON文件，则开始加载数据
            stopLoading = true;
            fr.onload = () => {
                // 读取文件数据并发送给工作线程
                splatData = new Uint8Array(fr.result);
                console.log("Loaded", Math.floor(splatData.length / rowLength));

                // 检查文件头是否为PLY文件的标识
                if (
                    splatData[0] == 112 &&
                    splatData[1] == 108 &&
                    splatData[2] == 121 &&
                    splatData[3] == 10
                ) {
                    // 如果是PLY文件，则特殊处理
                    worker.postMessage({ ply: splatData.buffer });
                } else {
                    // 否则，正常发送数据
                    worker.postMessage({
                        buffer: splatData.buffer,
                        vertexCount: Math.floor(splatData.length / rowLength),
                    });
                }
            };
            // 以ArrayBuffer形式读取文件
            fr.readAsArrayBuffer(file);
        }
    };

    // 监听URL哈希变化事件
    window.addEventListener("hashchange", (e) => {
        try {
            // 尝试从URL哈希中解析视图矩阵
            viewMatrix = JSON.parse(decodeURIComponent(location.hash.slice(1)));
            carousel = false; // 停止旋转展示模式
        } catch (err) {}
    });

    // 阻止默认的拖放事件
    const preventDefault = (e) => {
        e.preventDefault();
        e.stopPropagation();
    };
    document.addEventListener("dragenter", preventDefault);
    document.addEventListener("dragover", preventDefault);
    document.addEventListener("dragleave", preventDefault);
    // 处理文件拖放事件
    document.addEventListener("drop", (e) => {
        e.preventDefault();
        e.stopPropagation();
        // 选择拖放的文件
        selectFile(e.dataTransfer.files[0]);
    });

    // 初始化读取的字节数和上一次的顶点计数
    let bytesRead = 0;
    let lastVertexCount = -1;
    let stopLoading = false;

    // 循环读取数据
    while (true) {
        const { done, value } = await reader.read();
        // 如果读取完成或停止加载，则退出循环
        if (done || stopLoading) break;

        // 将读取的数据添加到splatData中
        splatData.set(value, bytesRead);
        bytesRead += value.length;

        // 如果顶点计数有变化，则发送数据给工作线程
        if (vertexCount > lastVertexCount) {
            worker.postMessage({
                buffer: splatData.buffer,
                vertexCount: Math.floor(bytesRead / rowLength),
            });
            lastVertexCount = vertexCount;
        }
    }
    // 如果没有停止加载，则发送最终数据给工作线程
    if (!stopLoading)
        worker.postMessage({
            buffer: splatData.buffer,
            vertexCount: Math.floor(bytesRead / rowLength),
        });
}
function simulateKeyPress(key) {
    console.log("Simulating key press: " + key);
    var event = new KeyboardEvent('keydown', {'key': key});
    document.dispatchEvent(event);

    // 如果按下的是 'P' 键，执行特定操作
    if (key === 'P') {
        // 这里执行按下 'P' 键后的操作，例如设置 carousel 为 true 并清空 camid 的文本内容
        carousel = true;
        camid.innerText = "";
    }
    if (key=== '0'){
        carousel = false;
        console.log(viewMatrix)
        camstart = viewMatrix
        camend = cams[0]
        // 调用函数以3秒的持续时间开始动画
        changeViewAnimation(camstart,camend,5000);
    }
        if (key=== '1'){
        carousel = false;
        console.log(viewMatrix)
        camstart = viewMatrix
        camend = cams[1]
        // 调用函数以3秒的持续时间开始动画
        changeViewAnimation(camstart,camend,5000);
    }
            if (key=== '2'){
        carousel = false;
        console.log(viewMatrix)
        camstart = viewMatrix
        camend = cams[2]
        // 调用函数以3秒的持续时间开始动画
        changeViewAnimation(camstart,camend,5000);
    }
}
async function main(){
    await renderer()

}
// 主函数，捕获并显示错误信息
main().catch((err) => {
    document.getElementById("spinner").style.display = "none";
    document.getElementById("message").innerText = err.toString();
});
